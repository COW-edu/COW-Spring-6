**-JDBC :** 자바 프로그램이 데이터베이스와 연결되어 데이터를 주고받을 수 있게 해주는 자바 표준 API 
(직접 SQL문 작성, DB 연결/해제 등 모든 과정을 수동으로 코딩)

**-JPA :** 자바의 ORM(객체를 테이블로 연결)기술을 쉽게 구현하도록 도와주는 API 
(자바 클래스를 사용하면 JPA가 알아서 SQL을 생성해 DB에 전송)

**-Lombok :** 자바 컴파일 시점에 어노테이션을 분석하여 Getter, Setter, 생성자 등의 반복적인 코드를 자동으로 생성해주는 라이브러리

compose.yaml : 가상의 데이터베이스 설치 & 실행  
application.yml : 스프링 앱의 설정 파일  

---

**-Lombok 어노테이션**
@Setter: 값을 변경하는 메서드를 자동 생성  
@Getter: 클래스 내의 모든 필드에 대해 값을 조회할 수 있는 접근자 메서드 자동 생성  
(user.getName()이라는 메서드 자동 생성)  
@Builder: 빌더 패턴을 자동으로 구현하여, 객체 생성 시 유연하고 가독성 높게 값을 주입  
(생성자는 파라미터 순서를 외워야 해서 실수하기 쉬움. 빌더를 쓰면 키=값 형태로 명확하게 객체 생성 가능(User.builder().name(“ ”) ..))  
@NoArgsConstructor: 파라미터가 없는 기본 생성자 생성 (JPA 필수 요소)  
@AllArgsConstructor: 클래스의 모든 필드를 파라미터로 받는 생성자 생성   
(@Builder가 내부적으로 전체 생성자를 필요로 하기 때문에 보통 세트처럼 붙여줌)   

**-JPA 어노테이션(DB 매핑 관련)**
@Entity: 해당 클래스가 JPA가 관리하는 Entity임을 명시하여, DB의 테이블과 매핑됨을 선언  
@Table: 엔티티와 매핑할 DB 테이블의 이름이나 세부 설정 지정  
@Id: 해당 필드가 엔티티의 기본 키임을 지정  
@GeneratedValue: 기본 키의 생성 전략을 지정  
@Column: 객체 필드를 테이블의 컬럼과 매핑하며, 제약 조건 설정  

---

**Controller : 웹 브라우저의 URL 요청을 받음**
-UserController : URL 주소로 교통정리  
@RestController: 화면을 렌더링하는 것이 아닌, 데이터를 그대로 응답하는 REST API용 컨트롤러  
(메서드가 리턴하는 값을 JSON 문자열로 바꿔 응답 본문에 넣음)  
@RequestMapping("/boards"): URL이 /boards로 시작하는 요청은 해당 클래스에 보냄  
@RequestParam: 쿼리 파라미터. URL 뒤에 물음표 붙고 나오는 값을 찾아 삽입  
@RequestBody: 요청 본문. Dto에 맞게 자동 매핑해 객체로 전달  
**Service : 요청 받은 걸로 비즈니스 로직 실행**  
-UserService : 비즈니스 로직 실행  
@Transactional: 데이터베이스의 상태를 변경하는 여러 작업을 하나의 논리적인 단위로 묶어, 모두 성공하거나 아예 없던 일로 만드는 기술  
**Repository : 데이터베이스 관리**  
-UserRepository : DB 접근  
**Dto/Entity : 데이터**  
-User(Entity) : DB 테이블 그 자체  
-UserDto(DTO) : 프론트엔트와 소통하는 양식  
=> DB용과 통신용을 따로 관리하는 게 정석     

Input(Controller): JSON 데이터를 받아서 DTO 변환  
Processing(Service): 비즈니스 로직 수행. 데이터 형식 변환(DTO ↔ Entity) 및 트랜잭션 관리  
Output/Storage(Repository): 데이터베이스와의 입출력 담당. SQL 자동 생성.  

#### 흐름: Client -> Controller -> Service -> Repository -> Database  

---

1:N 관계에서 양방향 매핑은 필수가 아님  
저장만 할 거라면, N쪽에서만 참조해도 가능  
조회를 할 거라면(User입장에서 boardList를 꺼내보고 싶을 때(user.getBoards())), 1쪽에서도 매핑해야 함  
@OneToMany(mappedBy = "user", cascade = CascadeType.ALL)  
mappedBy = "user": 연관관계의 주인이 아님을 설정  
CascadeType.ALL: 부모(User)가 삭제되면 자식(Board)들도 같이 삭제  

---

의존성 주입: 객체가 필요로 하는 부품(의존성)을 내부에서 직접 생성(new)하지 않고, 스프링 컨테이너(외부)가 넣어주는 방식  
생성자 주입: 의존성 주입을 하는 방법은 여러 가지가 있는데, 그 중 생성자를 통해서 넣는 방법  
계층형 아키텍처: 소프트웨어를 수평적인 계층으로 나누어, 각 계층이 자신의 역할에만 집중하게 만드는 설계 패턴  
-프레젠테이션 계층(Controller)  
-비즈니스 계층(Service)  
-데이터 접근 계층(Repository)  
 
